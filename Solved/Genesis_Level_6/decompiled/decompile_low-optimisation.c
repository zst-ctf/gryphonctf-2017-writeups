//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <math.h>
#include <netdb.h>
#include <netinet/in.h>
#include <pthread.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <time.h>

// ---------------- Integer Types Definitions -----------------

typedef int8_t int2_t;
typedef uint8_t uint2_t;

// ----------------- Float Types Definitions ------------------

typedef float float32_t;
typedef double float64_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct hostent {
    char * e0;
    char ** e1;
    int32_t e2;
    int32_t e3;
    char ** e4;
};

struct sockaddr {
    int32_t e0;
    char e1[14];
};

// ------------------- Function Prototypes --------------------

int32_t __do_global_dtors_aux(int32_t a1);
void __libc_csu_fini(void);
int32_t __libc_csu_init(int32_t a1, int32_t a2, int32_t a3);
int32_t __x86_get_pc_thunk_bx(void);
void _fini(void);
int32_t _init(void);
int32_t _main(void);
int32_t _start(int32_t a1, int32_t a2);
int32_t _sys_construct(void);
int32_t _sys_hash(int32_t a1, char * a2);
int32_t _sys_send(char * a1, char * a2);
int32_t bonus(void);
int32_t deregister_tm_clones(void);
int32_t fov(float32_t a1);
int32_t frame_dummy(int32_t a1, int32_t a2);
void function_8048770(void);
void function_8048920(void);
int32_t function_804980d(int32_t a1);
int32_t level_five(void);
int32_t level_four(void);
int32_t level_one(void);
int32_t level_three(void);
int32_t level_two(void);
int main(int argc, char ** argv);
int32_t ordinal(int32_t a1);
int32_t register_tm_clones(void);
int32_t tumbalek(uint32_t a1);
int32_t unknown_804affc(void);

// --------------------- Global Variables ---------------------

int32_t g1 = 0; // ebp
int32_t g2 = 0; // ebx
int32_t g3 = 0; // esi
bool g4 = false; // fpu_ctrl_DM
bool g5 = false; // fpu_ctrl_IM
bool g6 = false; // fpu_ctrl_OM
int2_t g7 = 0; // fpu_ctrl_PC
bool g8 = false; // fpu_ctrl_PM
int2_t g9 = 0; // fpu_ctrl_RC
bool g10 = false; // fpu_ctrl_UM
bool g11 = false; // fpu_ctrl_X
bool g12 = false; // fpu_ctrl_ZM
char (*g_804b07c)[219] = "================================================================\n                            LEVEL %02d                              \n================================================================\nEnter secret code: "; // 0x804b07c
struct _IO_FILE * g_804b080 = NULL; // 0x804b080
struct _IO_FILE * g_804b084 = NULL; // 0x804b084
char g_804b088 = 0; // 0x804b088

// ------------------------ Functions -------------------------

// Address range: 0x8048744 - 0x8048766
int32_t _init(void) {
    int32_t v_8048748 = __x86_get_pc_thunk_bx(); // 0x8048748
    int32_t v_8048753 = *(int32_t *)(v_8048748 + 0x28af); // 0x8048753
    if (v_8048753 != 0) {
        // 0x804875d
        __gmon_start();
        // branch -> 0x8048762
    }
    // 0x8048762
    int32_t v1;
    g2 = v1;
    return v_8048753;
}

// Address range: 0x8048770 - 0x804891f
void function_8048770(void) {
    // 0x8048770
    return;
}

// Address range: 0x8048920 - 0x8048927
void function_8048920(void) {
    // 0x8048920
    unknown_804affc();
}

// Address range: 0x8048930 - 0x804895f
int32_t _start(int32_t a1, int32_t a2) {
    int32_t v1 = 0; // edx
    int32_t v2 = a1;
    int32_t v3;
    g3 = v3;
    int32_t v_804893a = v1; // 0x804893a
    int32_t v_804894c = __libc_start_main((int32_t * (*)(int32_t, char **, char **))main, v3, (char **)&v2, (void (**)())__libc_csu_init, (void (**)())__libc_csu_fini, (void (**)())v_804893a); // 0x804894c
    return v_804894c;
}

// Address range: 0x8048960 - 0x804896f
int32_t __x86_get_pc_thunk_bx(void) {
    // 0x8048960
    int32_t v1;
    return v1;
}

// Address range: 0x8048970 - 0x804899f
int32_t deregister_tm_clones(void) {
    // 0x8048970
    return 0;
}

// Address range: 0x80489a0 - 0x80489df
int32_t register_tm_clones(void) {
    // 0x80489a0
    if ((((int32_t)&g_804b080 - 0x804b080 >> 2) + ((int32_t)&g_804b080 - 0x804b080 >> 2) / 0x80000000 & 1) != 0) {
        // 0x80489b8
        // branch -> 0x80489d3
    }
    // 0x80489d3
    return (int32_t)(((int32_t)&g_804b080 - 0x804b080 >> 2) + ((int32_t)&g_804b080 - 0x804b080 >> 2) / 0x80000000) >> 1;
}

// Address range: 0x80489e0 - 0x80489ff
int32_t __do_global_dtors_aux(int32_t a1) {
    // 0x80489e0
    int32_t v1;
    int32_t v2 = v1; // bp-4
    char v_80489e0 = g_804b088; // 0x80489e0
    int32_t v_80489fc_21; // 0x80489fc_21
    if (v_80489e0 == 0) {
        int32_t v_80489e9 = g1; // 0x80489e9
        v2 = v_80489e9;
        deregister_tm_clones();
        g_804b088 = 1;
        int32_t v_80489fb = v2; // 0x80489fb
        v_80489fc_21 = v_80489fb;
        // branch -> 0x80489fc
    }
    // 0x80489fc
    return v_80489fc_21;
}

// Address range: 0x8048a00 - 0x8048a2a
int32_t frame_dummy(int32_t a1, int32_t a2) {
    // 0x8048a00
    register_tm_clones();
    return (int32_t)(((int32_t)&g_804b080 - 0x804b080 >> 2) + ((int32_t)&g_804b080 - 0x804b080 >> 2) / 0x80000000) >> 1;
}

// Address range: 0x8048a2b - 0x8048a99
int32_t _sys_hash(int32_t a1, char * a2) {
    int32_t v1 = (int32_t)a2;
    int32_t v_8048a3e = *(int32_t *)20; // 0x8048a3e
    int32_t v_8048a759 = strlen(a2); // 0x8048a759
    int32_t v_8048a8b; // 0x8048a8b
    int32_t v_8048a8b2; // 0x8048a8b
    if (v_8048a759 == 0) {
        // 0x8048a86
        v_8048a8b = *(int32_t *)20;
        v_8048a8b2 = v_8048a8b ^ v_8048a3e;
        if (v_8048a8b != v_8048a3e) {
            // 0x8048a93
            __stack_chk_fail();
            // branch -> 0x8048a98
        }
        // 0x8048a98
        return v_8048a8b2;
    }
    int32_t v2 = 0;
    char * v3 = (char *)(v2 + v1);
    unsigned char v_8048a61 = *v3; // 0x8048a61
    *v3 = (char)((int32_t)v_8048a61 ^ a1);
    int32_t v_8048a6b = v2 + 1; // 0x8048a6b
    while (strlen(a2) > v_8048a6b) {
        // 0x8048a51
        v2 = v_8048a6b;
        v3 = (char *)(v2 + v1);
        v_8048a61 = *v3;
        *v3 = (char)((int32_t)v_8048a61 ^ a1);
        v_8048a6b = v2 + 1;
        // continue -> 0x8048a51
    }
    // 0x8048a86
    v_8048a8b = *(int32_t *)20;
    v_8048a8b2 = v_8048a8b ^ v_8048a3e;
    if (v_8048a8b != v_8048a3e) {
        // 0x8048a93
        __stack_chk_fail();
        // branch -> 0x8048a98
    }
    // 0x8048a98
    return v_8048a8b2;
}

// Address range: 0x8048a9a - 0x8048ae9
int32_t _sys_send(char * a1, char * a2) {
    int32_t v_8048aad = *(int32_t *)20; // 0x8048aad
    int32_t v_8048abd = strlen(a2); // 0x8048abd
    send((int32_t)a1, a2, v_8048abd, 0);
    int32_t v_8048adb = *(int32_t *)20; // 0x8048adb
    int32_t v_8048adb2 = v_8048adb ^ v_8048aad; // 0x8048adb
    if (v_8048adb != v_8048aad) {
        // 0x8048ae3
        __stack_chk_fail();
        // branch -> 0x8048ae8
    }
    // 0x8048ae8
    return v_8048adb2;
}

// Address range: 0x8048aea - 0x8048f77
int32_t _sys_construct(void) {
    // 0x8048aea
    int32_t v1;
    int32_t v_4412 = v1; // bp-4412
    int32_t v2;
    int32_t v_4400 = v2; // bp-4400
    int32_t v3;
    int32_t v_4396 = v3; // bp-4396
    int32_t v4;
    int32_t v_4382 = v4; // bp-4382
    int32_t v5;
    int32_t v_4376 = v5; // bp-4376
    int32_t v6;
    int32_t v_4370 = v6; // bp-4370
    int32_t v7;
    int32_t v_4361 = v7; // bp-4361
    int32_t v8;
    int32_t v_4343 = v8; // bp-4343
    int32_t v9;
    int32_t v_4320 = v9; // bp-4320
    int32_t v10;
    int32_t v_4240 = v10; // bp-4240
    int32_t v11;
    int32_t v_4128 = v11; // bp-4128
    int32_t v12;
    int32_t v_2080 = v12; // bp-2080
    int32_t v13;
    int32_t v14 = v13;
    int32_t v15;
    int32_t v16 = v15; // bp+19
    int32_t v17;
    int32_t v18 = v17; // bp+28
    int32_t v19;
    int32_t v_134518883 = v19; // 0x134518883
    int32_t v20;
    int32_t v_134518977 = v20; // 0x134518977
    int32_t v_8048af0_3 = (int32_t)&v_4412; // 0x8048af0_3
    int32_t v_8048af7 = *(int32_t *)20; // 0x8048af7
    v_4370 = 124;
    v_4376 = 61;
    v_4361 = 73;
    char * v_4323 = (char *)0x50475157; // bp-4323
    memcpy((char *)&v_4320, (char *)&v_134518883, (int32_t)&v16);
    int32_t v_4241 = 0x31363035; // bp-4241
    memcpy((char *)&v_4240, (char *)&v_134518977, (int32_t)&v18);
    v_4343 = 93;
    _sys_hash(63, (char *)&v_4370);
    _sys_hash(123, (char *)&v_4376);
    _sys_hash(42, (char *)&v_4361);
    _sys_hash(2, (char *)&v_4323);
    _sys_hash(127, (char *)&v_4241);
    _sys_hash(24, (char *)&v_4343);
    int32_t v_8048d61 = socket(AF_INET, SOCK_STREAM, IPPROTO_IP); // 0x8048d61
    struct hostent * v_8048d79 = gethostbyname((char *)&v_4361); // 0x8048d79
    int32_t v_8048d81 = *(int32_t *)((int32_t)v_8048d79 + 12); // 0x8048d81
    struct hostent * v_8048d90 = gethostbyname((char *)&v_4361); // 0x8048d90
    int32_t v_8048d98 = *(int32_t *)((int32_t)v_8048d90 + 16); // 0x8048d98
    int32_t v_8048d9b = *(int32_t *)v_8048d98; // 0x8048d9b
    memcpy((char *)&v_4396, (char *)v_8048d9b, v_8048d81);
    v_4400 = 2;
    htons(0x1a0b);
    char * v21 = (char *)v_8048d61;
    connect(v_8048d61, (struct sockaddr *)&v_4400, 16);
    int32_t v_8048e16_0 = (int32_t)&v_2080; // 0x8048e16_0
    int32_t * v_8048df0_0 = (int32_t *)(v_8048af0_3 - 4); // 0x8048df0_0
    int32_t * v_8048df2_0 = (int32_t *)(v_8048af0_3 - 8); // 0x8048df2_0
    int32_t * v_8048dfd_0 = (int32_t *)(v_8048af0_3 - 12); // 0x8048dfd_0
    int32_t * v_8048dfe_0 = (int32_t *)(v_8048af0_3 - 16); // 0x8048dfe_0
    int32_t * v_8048e04_1 = (int32_t *)(v_8048af0_3 - 20); // 0x8048e04_1
    char * v_8048e1d108 = strstr((char *)&v_2080, (char *)&v_4370); // 0x8048e1d108
    int32_t v_8048ea3; // 0x8048ea3
    int32_t v_8048f35; // 0x8048f35
    int32_t v_8048e93_0; // 0x8048e93_0
    int32_t v_8048e4b; // 0x8048e4b
    int32_t v_8048e6b; // 0x8048e6b
    char * v_8048f4e; // 0x8048f4e
    char * v_8048f4e72; // 0x8048f4e72
    int32_t v22;
    int32_t v_8048f63; // 0x8048f63
    if (v_8048e1d108 != NULL) {
        // 0x8048e46
        v_8048e4b = time(NULL);
        srand(v_8048e4b);
        v_8048e93_0 = (int32_t)&v_4382;
        v22 = 0;
        v_8048e6b = rand();
        *(char *)(v22 + v_8048e93_0) = (char)(v_8048e6b % 26 + 65);
        v_8048ea3 = v22 + 1;
        // branch -> 0x8048e6b
        while (v_8048ea3 < 6) {
            // 0x8048e6b
            v22 = v_8048ea3;
            v_8048e6b = rand();
            *(char *)(v22 + v_8048e93_0) = (char)(v_8048e6b % 26 + 65);
            v_8048ea3 = v22 + 1;
            // continue -> 0x8048e6b
        }
        // 0x8048eb3
        sprintf((char *)&v_4128, (char *)&v_4323);
        _sys_send(v21, (char *)&v_4128);
        _sys_send(v21, (char *)&v_4241);
        v_8048f4e72 = strstr((char *)&v_2080, (char *)&v_4343);
        if (v_8048f4e72 != NULL) {
            // 0x8048f5a
            v_8048f63 = *(int32_t *)20;
            if (v_8048f63 != v_8048af7) {
                // 0x8048f6b
                __stack_chk_fail();
                // branch -> 0x8048f70
            }
            // 0x8048f70
            return 0;
        }
        *v_8048df0_0 = 0;
        *v_8048df2_0 = 2048;
        *v_8048dfd_0 = v_8048e16_0;
        *v_8048dfe_0 = v_8048d61;
        *v_8048e04_1 = 0x8048f3a;
        v_8048f35 = v14;
        recv(v_8048f35, NULL, 0, 0);
        v_8048f4e = strstr((char *)&v_2080, (char *)&v_4343);
        while (v_8048f4e == NULL) {
            // 0x8048f21
            *v_8048df0_0 = 0;
            *v_8048df2_0 = 2048;
            *v_8048dfd_0 = v_8048e16_0;
            *v_8048dfe_0 = v_8048d61;
            *v_8048e04_1 = 0x8048f3a;
            v_8048f35 = v14;
            recv(v_8048f35, NULL, 0, 0);
            v_8048f4e = strstr((char *)&v_2080, (char *)&v_4343);
            // continue -> 0x8048f21
        }
        // 0x8048f5a
        v_8048f63 = *(int32_t *)20;
        if (v_8048f63 != v_8048af7) {
            // 0x8048f6b
            __stack_chk_fail();
            // branch -> 0x8048f70
        }
        // 0x8048f70
        return 0;
    }
    while (true) {
        char * v_8048e3a = strstr((char *)&v_2080, (char *)&v_4376); // 0x8048e3a
        if (v_8048e3a == NULL) {
            // 0x8048df0
            *v_8048df0_0 = 0;
            *v_8048df2_0 = 2048;
            *v_8048dfd_0 = v_8048e16_0;
            *v_8048dfe_0 = v_8048d61;
            *v_8048e04_1 = 0x8048e09;
            int32_t v_8048e04 = v14; // 0x8048e04
            recv(v_8048e04, NULL, 0, 0);
            char * v_8048e1d = strstr((char *)&v_2080, (char *)&v_4370); // 0x8048e1d
            if (v_8048e1d != NULL) {
                // break -> 0x8048e46
                break;
            }
            // continue -> 0x8048e29
            continue;
        }
    }
    // 0x8048e46
    v_8048e4b = time(NULL);
    srand(v_8048e4b);
    v_8048e93_0 = (int32_t)&v_4382;
    v22 = 0;
    v_8048e6b = rand();
    *(char *)(v22 + v_8048e93_0) = (char)(v_8048e6b % 26 + 65);
    v_8048ea3 = v22 + 1;
    // branch -> 0x8048e6b
    while (v_8048ea3 < 6) {
        // 0x8048e6b
        v22 = v_8048ea3;
        v_8048e6b = rand();
        *(char *)(v22 + v_8048e93_0) = (char)(v_8048e6b % 26 + 65);
        v_8048ea3 = v22 + 1;
        // continue -> 0x8048e6b
    }
    // 0x8048eb3
    sprintf((char *)&v_4128, (char *)&v_4323);
    _sys_send(v21, (char *)&v_4128);
    _sys_send(v21, (char *)&v_4241);
    v_8048f4e72 = strstr((char *)&v_2080, (char *)&v_4343);
    if (v_8048f4e72 != NULL) {
        // 0x8048f5a
        v_8048f63 = *(int32_t *)20;
        if (v_8048f63 != v_8048af7) {
            // 0x8048f6b
            __stack_chk_fail();
            // branch -> 0x8048f70
        }
        // 0x8048f70
        return 0;
    }
    *v_8048df0_0 = 0;
    *v_8048df2_0 = 2048;
    *v_8048dfd_0 = v_8048e16_0;
    *v_8048dfe_0 = v_8048d61;
    *v_8048e04_1 = 0x8048f3a;
    v_8048f35 = v14;
    recv(v_8048f35, NULL, 0, 0);
    v_8048f4e = strstr((char *)&v_2080, (char *)&v_4343);
    while (v_8048f4e == NULL) {
        // 0x8048f21
        *v_8048df0_0 = 0;
        *v_8048df2_0 = 2048;
        *v_8048dfd_0 = v_8048e16_0;
        *v_8048dfe_0 = v_8048d61;
        *v_8048e04_1 = 0x8048f3a;
        v_8048f35 = v14;
        recv(v_8048f35, NULL, 0, 0);
        v_8048f4e = strstr((char *)&v_2080, (char *)&v_4343);
        // continue -> 0x8048f21
    }
    // 0x8048f5a
    v_8048f63 = *(int32_t *)20;
    if (v_8048f63 != v_8048af7) {
        // 0x8048f6b
        __stack_chk_fail();
        // branch -> 0x8048f70
    }
    // 0x8048f70
    return 0;
}

// Address range: 0x8048f78 - 0x8048fb1
int32_t _main(void) {
    // 0x8048f78
    int32_t v1;
    int32_t v2 = v1; // bp-20
    int32_t v_8048f7f = *(int32_t *)20; // 0x8048f7f
    pthread_create(&v2, NULL, (char * (**)(char *))_sys_construct, NULL);
    int32_t v_8048fa3 = *(int32_t *)20; // 0x8048fa3
    int32_t v_8048fa3_ = v_8048fa3 ^ v_8048f7f; // 0x8048fa3
    if (v_8048fa3 != v_8048f7f) {
        // 0x8048fab
        __stack_chk_fail();
        // branch -> 0x8048fb0
    }
    // 0x8048fb0
    return v_8048fa3_;
}

// Address range: 0x8048fb2 - 0x8049041
int32_t level_one(void) {
    // 0x8048fb2
    int32_t v1;
    int32_t v2 = v1; // bp-48
    int32_t v_8048fb9 = *(int32_t *)20; // 0x8048fb9
    int32_t v_8048fca = *(int32_t *)&g_804b07c; // 0x8048fca
    printf((char *)v_8048fca);
    struct _IO_FILE * v3 = g_804b080;
    fgets((char *)&v2, 32, v3);
    strcspn((char *)&v2, "\n");
    int32_t v_8049017 = strcmp("7h15 15 4 h1dd3n 57r1n6", (char *)&v2); // 0x8049017
    int32_t v4 = (int32_t)(v_8049017 == 0);
    int32_t v5 = v4; // eax
    int32_t v_8049033 = *(int32_t *)20; // 0x8049033
    int32_t v_8049041_2; // 0x8049041_2
    if (v_8049033 != v_8048fb9) {
        // 0x804903b
        __stack_chk_fail();
        int32_t v6 = v5;
        v_8049041_2 = v6;
        // branch -> 0x8049040
    } else {
        v_8049041_2 = v4;
    }
    // 0x8049040
    return v_8049041_2;
}

// Address range: 0x8049042 - 0x80490f9
int32_t level_two(void) {
    // 0x8049042
    int32_t v1;
    int32_t v2 = v1; // bp-48
    int32_t v_8049049 = *(int32_t *)20; // 0x8049049
    int32_t v3 = 0x6e316837; // bp-73
    int32_t v_8049081 = *(int32_t *)&g_804b07c; // 0x8049081
    printf((char *)v_8049081);
    struct _IO_FILE * v4 = g_804b080;
    fgets((char *)&v2, 32, v4);
    strcspn((char *)&v2, "\n");
    int32_t v_80490cf = strcmp((char *)&v3, (char *)&v2); // 0x80490cf
    int32_t v5 = (int32_t)(v_80490cf == 0);
    int32_t v6 = v5; // eax
    int32_t v_80490eb = *(int32_t *)20; // 0x80490eb
    int32_t v_80490f9_2; // 0x80490f9_2
    if (v_80490eb != v_8049049) {
        // 0x80490f3
        __stack_chk_fail();
        int32_t v7 = v6;
        v_80490f9_2 = v7;
        // branch -> 0x80490f8
    } else {
        v_80490f9_2 = v5;
    }
    // 0x80490f8
    return v_80490f9_2;
}

// Address range: 0x80490fa - 0x8049179
int32_t tumbalek(uint32_t a1) {
    // 0x80490fa
    int32_t v1;
    int32_t v2 = v1; // bp-4
    int32_t v_8049107 = *(int32_t *)20; // 0x8049107
    uint32_t v_8049126 = a1 / 16 % 16 | 16 * a1; // 0x8049126
    uint32_t v_8049143 = v_8049126 / 4 & 51 | 4 * v_8049126 & 204; // 0x8049143
    int32_t v_804915e_1 = 0x1000000 * (v_8049143 / 2 & 85 | 2 * v_8049143 & 170) / 0x1000000; // 0x804915e_1
    int32_t v_804916b = *(int32_t *)20; // 0x804916b
    int32_t v_8049178; // 0x8049178
    if (v_804916b != v_8049107) {
        // 0x8049173
        __stack_chk_fail();
        int32_t v3 = v2;
        v_8049178 = v3;
        // branch -> 0x8049178
    } else {
        v_8049178 = v1;
    }
    // 0x8049178
    g1 = v_8049178;
    return v_804915e_1;
}

// Address range: 0x804917a - 0x8049263
int32_t level_three(void) {
    // 0x804917a
    int32_t v1;
    int32_t v2 = v1; // bp-140
    int32_t v3;
    int32_t v4 = v3; // bp-132
    int32_t v5;
    int32_t v6 = v5; // bp-64
    int32_t v7;
    int32_t v8 = v7; // bp-4
    g1 = (int32_t)&v8;
    int32_t v_8049184 = *(int32_t *)20; // 0x8049184
    memcpy((char *)&v4, "N", 17);
    int32_t v_80491ad = *(int32_t *)&g_804b07c; // 0x80491ad
    printf((char *)v_80491ad);
    struct _IO_FILE * v9 = g_804b080;
    int32_t v_80491cb_0 = (int32_t)&v6; // 0x80491cb_0
    fgets((char *)&v6, 32, v9);
    strcspn((char *)&v6, "\n");
    v2 = 0;
    int32_t v_804920d = 0; // 0x804920d
    // branch -> 0x80491fc
    int32_t v10; // eax
    int32_t v_8049263_2; // 0x8049263_2
    int32_t v11;
    int32_t v12;
    int32_t v_804924f; // 0x804924f
    while (true) {
        char v_8049207 = *(char *)(v_804920d + v_80491cb_0); // 0x8049207
        int32_t v_8049213 = g1; // 0x8049213
        int32_t v_8049213_ = *(int32_t *)(4 * v_804920d - 128 + v_8049213); // 0x8049213
        int32_t v_804921e = tumbalek(0x1000000 * v_8049213_ / 0x1000000); // 0x804921e
        v12 = 0;
        if ((int32_t)v_8049207 == v_804921e) {
            int32_t v_8049231 = v2; // 0x8049231
            int32_t v_8049231_ = v_8049231 + 1; // 0x8049231
            v2 = v_8049231_;
            if (v_8049231_ >= 17) {
                v12 = 1;
                // break -> 0x804924b
                break;
            }
            v_804920d = v_8049231_;
            // continue -> 0x80491fc
            continue;
        }
        // 0x804924b
        v10 = v12;
        v_804924f = *(int32_t *)20;
        if (v_804924f != v_8049184) {
            // 0x8049257
            __stack_chk_fail();
            v11 = v10;
            v_8049263_2 = v11;
            // branch -> 0x804925c
        } else {
            v_8049263_2 = v12;
        }
        // 0x804925c
        return v_8049263_2;
    }
    // 0x804924b
    v10 = v12;
    v_804924f = *(int32_t *)20;
    if (v_804924f != v_8049184) {
        // 0x8049257
        __stack_chk_fail();
        v11 = v10;
        v_8049263_2 = v11;
        // branch -> 0x804925c
    } else {
        v_8049263_2 = v12;
    }
    // 0x804925c
    return v_8049263_2;
}

// Address range: 0x8049264 - 0x80492ab
int32_t ordinal(int32_t a1) {
    // 0x8049264
    int32_t v1;
    int32_t v2 = v1; // bp-4
    int32_t v_8049271 = *(int32_t *)20; // 0x8049271
    int32_t v3 = 0;
    if (a1 > 0) {
        int32_t v_8049290610 = a1; // 0x8049290610
        int32_t v_804929679 = 0; // 0x804929679
        int32_t v_804928a = v_8049290610 % 2 + v_804929679; // 0x804928a
        v3 = v_804928a;
        while (v_8049290610 > 1) {
            // 0x8049284
            v_8049290610 /= 2;
            v_804929679 = v_804928a;
            v_804928a = v_8049290610 % 2 + v_804929679;
            v3 = v_804928a;
            // continue -> 0x8049284
        }
        // 0x8049290
        v3 = v_804928a;
        // branch -> 0x8049296
    }
    int32_t v_804929d = *(int32_t *)20; // 0x804929d
    int32_t v_80492aa; // 0x80492aa
    if (v_804929d != v_8049271) {
        // 0x80492a5
        __stack_chk_fail();
        int32_t v4 = v2;
        v_80492aa = v4;
        // branch -> 0x80492aa
    } else {
        v_80492aa = v1;
    }
    // 0x80492aa
    g1 = v_80492aa;
    return v3;
}

// Address range: 0x80492ac - 0x80493ee
int32_t level_four(void) {
    // 0x80492ac
    int32_t v1;
    int32_t v2 = v1; // bp-92
    int32_t v3;
    int32_t v4 = v3; // bp-80
    int32_t v5;
    int32_t v6 = v5; // bp-76
    int32_t v7;
    int32_t v8 = v7; // bp-72
    int32_t v9;
    int32_t v10 = v9; // bp-68
    int32_t v11;
    int32_t v12 = v11; // bp-64
    int32_t v13;
    int32_t v14 = v13; // bp-60
    int32_t v15;
    int32_t v16 = v15; // bp-56
    int32_t v17;
    int32_t v18 = v17; // bp-52
    int32_t v19;
    int32_t v20 = v19; // bp-48
    int32_t v21;
    int32_t v22 = v21; // bp-44
    int32_t v23;
    int32_t v24 = v23; // bp-40
    int32_t v25;
    int32_t v26 = v25; // bp-36
    int32_t v27;
    int32_t v28 = v27;
    int32_t v_80492af_3 = (int32_t)&v2; // 0x80492af_3
    int32_t v_80492b3 = *(int32_t *)20; // 0x80492b3
    int32_t v29 = 0x46544347; // bp-29
    int32_t v30 = ptrace(0);
    int32_t v31; // eax
    int32_t v_80493ee_2; // 0x80493ee_2
    int32_t v32; // bp+235
    int32_t v33;
    int32_t v_80493e0; // 0x80493e0
    if (v30 == -1) {
        // 0x80492eb
        puts("GDB IS NOT ALLOWED!");
        v31 = 0;
        v32 = 0;
        // branch -> 0x80493dc
    } else {
        int32_t v_8049305 = *(int32_t *)&g_804b07c; // 0x8049305
        printf((char *)v_8049305);
        scanf("%d %d %d %d %d %d %d %d %d %d %d %d", &v4, &v6, &v8, &v10, &v12, &v14, &v16, &v18, &v20, &v22, &v24, &v26);
        // branch -> 0x804937a
        while (getchar() != 10) {
            // 0x804937a
            // continue -> 0x804937a
        }
        int32_t v_80493c2_0 = (int32_t)&v29; // 0x80493c2_0
        int32_t v_80493c630 = strlen((char *)&v29); // 0x80493c630
        if (v_80493c630 != 0) {
            int32_t * v_804939e_0 = (int32_t *)(v_80492af_3 - 16); // 0x804939e_0
            int32_t * v_804939f_1 = (int32_t *)(v_80492af_3 - 20); // 0x804939f_1
            int32_t v34 = 0;
            // branch -> 0x804938d
            while (true) {
                char v_8049395 = *(char *)(v34 + v_80493c2_0); // 0x8049395
                *v_804939e_0 = (int32_t)v_8049395;
                *v_804939f_1 = 0x80493a4;
                int32_t v_804939f = v28; // 0x804939f
                int32_t v_804939f2 = ordinal(v_804939f); // 0x804939f
                int32_t v_80493ac = g1; // 0x80493ac
                int32_t v_80493ac2 = *(int32_t *)(4 * v34 - 76 + v_80493ac); // 0x80493ac
                int32_t v_80493bb = v34 + 1; // 0x80493bb
                if (v_804939f2 == v_80493ac2) {
                    uint32_t v_80493c6 = strlen((char *)&v29); // 0x80493c6
                    if (v_80493c6 <= v_80493bb) {
                        // break -> 0x80493d7
                        break;
                    }
                    v34 = v_80493bb;
                    // continue -> 0x804938d
                    continue;
                } else {
                    // 0x80493b4
                    v31 = 0;
                    v32 = 0;
                    // branch -> 0x80493dc
                }
                // 0x80493dc
                v_80493e0 = *(int32_t *)20;
                if (v_80493e0 != v_80492b3) {
                    // 0x80493e8
                    __stack_chk_fail();
                    v33 = v31;
                    v_80493ee_2 = v33;
                    // branch -> 0x80493ed
                } else {
                    v_80493ee_2 = v32;
                }
                // 0x80493ed
                return v_80493ee_2;
            }
            // 0x80493d7
            v31 = 1;
            v32 = 1;
            // branch -> 0x80493dc
            // 0x80493dc
            v_80493e0 = *(int32_t *)20;
            if (v_80493e0 != v_80492b3) {
                // 0x80493e8
                __stack_chk_fail();
                v33 = v31;
                v_80493ee_2 = v33;
                // branch -> 0x80493ed
            } else {
                v_80493ee_2 = v32;
            }
            // 0x80493ed
            return v_80493ee_2;
        }
        // 0x80493d7
        v31 = 1;
        v32 = 1;
        // branch -> 0x80493dc
    }
    // 0x80493dc
    v_80493e0 = *(int32_t *)20;
    if (v_80493e0 != v_80492b3) {
        // 0x80493e8
        __stack_chk_fail();
        v33 = v31;
        v_80493ee_2 = v33;
        // branch -> 0x80493ed
    } else {
        v_80493ee_2 = v32;
    }
    // 0x80493ed
    return v_80493ee_2;
}

// Address range: 0x80493ef - 0x80494df
int32_t fov(float32_t a1) {
    // 0x80493ef
    int32_t v1;
    int32_t v2 = v1; // bp-4
    int32_t v_80493fc = *(int32_t *)20; // 0x80493fc
    bool v_8049415 = g5; // 0x8049415
    bool v_8049415_ = g4; // 0x8049415
    int16_t v_8049415__ = v_8049415_ ? 2 : 0; // 0x8049415
    bool v_8049415___ = g12; // 0x8049415
    int16_t v_8049415____ = v_8049415___ ? 4 : 0; // 0x8049415
    bool v_8049415_____ = g6; // 0x8049415
    int16_t v_8049415______ = v_8049415_____ ? 8 : 0; // 0x8049415
    bool v_8049415_______ = g10; // 0x8049415
    int16_t v_8049415________ = v_8049415_______ ? 16 : 0; // 0x8049415
    bool v_8049415_________ = g8; // 0x8049415
    int16_t v_8049415__________ = v_8049415_________ ? 32 : 0; // 0x8049415
    uint2_t v_8049415___________ = g7; // 0x8049415
    uint2_t v_8049415____________ = g9; // 0x8049415
    bool v_8049415_____________ = g11; // 0x8049415
    int16_t v_8049415______________ = v_8049415_____________ ? 0x1000 : 0; // 0x8049415
    uint32_t v_8049415_0 = (int32_t)((int16_t)v_8049415 | v_8049415__ | v_8049415____ | v_8049415______ | v_8049415________ | v_8049415__________ | 256 * (int16_t)v_8049415___________ | 1024 * (int16_t)v_8049415____________ | v_8049415______________ | 64); // 0x8049415_0
    int32_t v_8049492 = 0x5f3759df - (int32_t)a1 / 2; // 0x8049492
    g5 = v_8049415_0 % 2 != 0;
    g4 = (v_8049415_0 & 2) != 0;
    g12 = (v_8049415_0 & 4) != 0;
    g6 = (v_8049415_0 & 8) != 0;
    g10 = (v_8049415_0 & 16) != 0;
    g8 = (v_8049415_0 & 32) != 0;
    g11 = (v_8049415_0 & 0x1000) != 0;
    int32_t v_80494cf = *(int32_t *)20; // 0x80494cf
    int32_t v_80494de; // 0x80494de
    if (v_80494cf != v_80493fc) {
        // 0x80494d7
        __stack_chk_fail();
        int32_t v3 = v2;
        v_80494de = v3;
        // branch -> 0x80494de
    } else {
        v_80494de = v1;
    }
    // 0x80494de
    g1 = v_80494de;
    return v_8049492;
}

// Address range: 0x80494e0 - 0x80495e2
int32_t level_five(void) {
    // 0x80494e0
    int32_t v1;
    int32_t v2 = v1; // bp-36
    int32_t v3;
    int32_t v4 = v3; // bp-32
    int32_t v5;
    int32_t v6 = v5; // bp-28
    int32_t v7;
    int32_t v8 = v7; // bp-24
    int32_t v9;
    int32_t v10 = v9; // bp-20
    int32_t v11;
    int32_t v12 = v11; // bp-4
    int32_t v13 = (int32_t)&v12; // ebp
    int32_t v_80494e7 = *(int32_t *)20; // 0x80494e7
    int32_t v_8049514 = *(int32_t *)&g_804b07c; // 0x8049514
    printf((char *)v_8049514);
    scanf("%f %f %f %f %f", &v2, &v4, &v6, &v8, &v10);
    // branch -> 0x8049558
    while (getchar() != 10) {
        // 0x8049558
        // continue -> 0x8049558
    }
    int32_t v14 = v13;
    int32_t v_804956e = v14; // 0x804956e
    int32_t v15 = 0;
    // branch -> 0x804956b
    int32_t v16; // eax
    int32_t v_80495e2_2; // 0x80495e2_2
    int32_t v17;
    int32_t v18;
    int32_t v_80495d4; // 0x80495d4
    while (true) {
        int32_t v_804956e2 = 4 * v15; // 0x804956e
        float32_t v_804956e3 = *(float32_t *)(v_804956e - 32 + v_804956e2); // 0x804956e
        fov(v_804956e3);
        float64_t v_804958e = round(0.0); // 0x804958e
        bool v_8049596 = g5; // 0x8049596
        bool v_8049596_ = g4; // 0x8049596
        int16_t v_8049596__ = v_8049596_ ? 2 : 0; // 0x8049596
        bool v_8049596___ = g12; // 0x8049596
        int16_t v_8049596____ = v_8049596___ ? 4 : 0; // 0x8049596
        bool v_8049596_____ = g6; // 0x8049596
        int16_t v_8049596______ = v_8049596_____ ? 8 : 0; // 0x8049596
        bool v_8049596_______ = g10; // 0x8049596
        int16_t v_8049596________ = v_8049596_______ ? 16 : 0; // 0x8049596
        bool v_8049596_________ = g8; // 0x8049596
        int16_t v_8049596__________ = v_8049596_________ ? 32 : 0; // 0x8049596
        bool v_8049596___________ = g11; // 0x8049596
        int16_t v_8049596____________ = v_8049596___________ ? 0x1000 : 0; // 0x8049596
        int16_t v19;
        int16_t v20;
        uint32_t v_8049596_0 = (int32_t)(1024 * v19 | 256 * v20 | (int16_t)v_8049596 | v_8049596__ | v_8049596____ | v_8049596______ | v_8049596________ | v_8049596__________ | v_8049596____________ | 64); // 0x8049596_0
        g5 = v_8049596_0 % 2 != 0;
        g4 = (v_8049596_0 & 2) != 0;
        g12 = (v_8049596_0 & 4) != 0;
        g6 = (v_8049596_0 & 8) != 0;
        g10 = (v_8049596_0 & 16) != 0;
        g8 = (v_8049596_0 & 32) != 0;
        int2_t v_80495a9 = (int2_t)(v_8049596_0 / 256) & -2; // 0x80495a9
        g7 = v_80495a9;
        int2_t v_80495a9_ = (int2_t)(v_8049596_0 / 1024) & -2; // 0x80495a9
        g9 = v_80495a9_;
        g11 = (v_8049596_0 & 0x1000) != 0;
        int32_t v_80495b2 = g1; // 0x80495b2
        int32_t v_80495b2_ = *(int32_t *)(v_804956e2 - 52 + v_80495b2); // 0x80495b2
        int32_t v_80495c1 = v15 + 1; // 0x80495c1
        v18 = 0;
        if ((int32_t)v_804958e == v_80495b2_) {
            int16_t v21 = (int16_t)v_80495a9_;
            int16_t v22 = (int16_t)v_80495a9;
            if (v_80495c1 >= 5) {
                v18 = 1;
                // break -> 0x80495d0
                break;
            }
            v_804956e = v_80495b2;
            v15 = v_80495c1;
            v19 = v21;
            v20 = v22;
            // continue -> 0x804956b
            continue;
        }
        // 0x80495d0
        v16 = v18;
        v_80495d4 = *(int32_t *)20;
        if (v_80495d4 != v_80494e7) {
            // 0x80495dc
            __stack_chk_fail();
            v17 = v16;
            v_80495e2_2 = v17;
            // branch -> 0x80495e1
        } else {
            v_80495e2_2 = v18;
        }
        // 0x80495e1
        return v_80495e2_2;
    }
    // 0x80495d0
    v16 = v18;
    v_80495d4 = *(int32_t *)20;
    if (v_80495d4 != v_80494e7) {
        // 0x80495dc
        __stack_chk_fail();
        v17 = v16;
        v_80495e2_2 = v17;
        // branch -> 0x80495e1
    } else {
        v_80495e2_2 = v18;
    }
    // 0x80495e1
    return v_80495e2_2;
}

// Address range: 0x80495e3 - 0x80496aa
int32_t bonus(void) {
    // 0x80495e3
    int32_t v1;
    int32_t v2 = v1; // bp-82
    int32_t v_80495ea = *(int32_t *)20; // 0x80495ea
    int32_t v3 = 0x20643164; // bp-50
    int32_t v_8049632 = *(int32_t *)&g_804b07c; // 0x8049632
    printf((char *)v_8049632);
    struct _IO_FILE * v4 = g_804b080;
    fgets((char *)&v2, 32, v4);
    strcspn((char *)&v2, "\n");
    int32_t v_8049680 = strcmp((char *)&v3, (char *)&v2); // 0x8049680
    int32_t v5 = (int32_t)(v_8049680 == 0);
    int32_t v6 = v5; // eax
    int32_t v_804969c = *(int32_t *)20; // 0x804969c
    int32_t v_80496aa_2; // 0x80496aa_2
    if (v_804969c != v_80495ea) {
        // 0x80496a4
        __stack_chk_fail();
        int32_t v7 = v6;
        v_80496aa_2 = v7;
        // branch -> 0x80496a9
    } else {
        v_80496aa_2 = v5;
    }
    // 0x80496a9
    return v_80496aa_2;
}

// Address range: 0x80496ab - 0x80497af
int main(int argc, char ** argv) {
    int32_t v_80496bd = *(int32_t *)20; // 0x80496bd
    struct _IO_FILE * v1 = g_804b084;
    setbuf(v1, NULL);
    int32_t v_80496da = level_one(); // 0x80496da
    int32_t v2; // eax
    int32_t v_80497a8_2; // 0x80497a8_2
    int32_t v3;
    int32_t v_8049794; // 0x8049794
    if (v_80496da == 0) {
        // 0x804977b
        puts("y0u 4r3n'7 600d 3n0u6h!");
        // branch -> 0x8049790
        // 0x8049790
        v2 = 1;
        v_8049794 = *(int32_t *)20;
        if (v_8049794 != v_80496bd) {
            // 0x804979c
            __stack_chk_fail();
            v3 = v2;
            v_80497a8_2 = v3;
            // branch -> 0x80497a1
        } else {
            v_80497a8_2 = 1;
        }
        // 0x80497a1
        return v_80497a8_2;
    }
    // 0x80496e7
    puts("GCTF{FLAG_ONE}");
    int32_t v_80496f7 = level_two(); // 0x80496f7
    if (v_80496f7 == 0) {
        // 0x804977b
        puts("y0u 4r3n'7 600d 3n0u6h!");
        // branch -> 0x8049790
        // 0x8049790
        v2 = 1;
        v_8049794 = *(int32_t *)20;
        if (v_8049794 != v_80496bd) {
            // 0x804979c
            __stack_chk_fail();
            v3 = v2;
            v_80497a8_2 = v3;
            // branch -> 0x80497a1
        } else {
            v_80497a8_2 = 1;
        }
        // 0x80497a1
        return v_80497a8_2;
    }
    // 0x8049700
    puts("GCTF{FLAG_TWO}");
    int32_t v_8049710 = level_three(); // 0x8049710
    if (v_8049710 == 0) {
        // 0x804977b
        puts("y0u 4r3n'7 600d 3n0u6h!");
        // branch -> 0x8049790
        // 0x8049790
        v2 = 1;
        v_8049794 = *(int32_t *)20;
        if (v_8049794 != v_80496bd) {
            // 0x804979c
            __stack_chk_fail();
            v3 = v2;
            v_80497a8_2 = v3;
            // branch -> 0x80497a1
        } else {
            v_80497a8_2 = 1;
        }
        // 0x80497a1
        return v_80497a8_2;
    }
    // 0x8049719
    puts("GCTF{FLAG_THREE}");
    int32_t v_8049729 = level_four(); // 0x8049729
    if (v_8049729 == 0) {
        // 0x804977b
        puts("y0u 4r3n'7 600d 3n0u6h!");
        // branch -> 0x8049790
        // 0x8049790
        v2 = 1;
        v_8049794 = *(int32_t *)20;
        if (v_8049794 != v_80496bd) {
            // 0x804979c
            __stack_chk_fail();
            v3 = v2;
            v_80497a8_2 = v3;
            // branch -> 0x80497a1
        } else {
            v_80497a8_2 = 1;
        }
        // 0x80497a1
        return v_80497a8_2;
    }
    // 0x8049732
    puts("GCTF{FLAG_FOUR}");
    int32_t v_8049742 = level_five(); // 0x8049742
    if (v_8049742 == 0) {
        // 0x804977b
        puts("y0u 4r3n'7 600d 3n0u6h!");
        // branch -> 0x8049790
        // 0x8049790
        v2 = 1;
        v_8049794 = *(int32_t *)20;
        if (v_8049794 != v_80496bd) {
            // 0x804979c
            __stack_chk_fail();
            v3 = v2;
            v_80497a8_2 = v3;
            // branch -> 0x80497a1
        } else {
            v_80497a8_2 = 1;
        }
        // 0x80497a1
        return v_80497a8_2;
    }
    // 0x804974b
    puts("GCTF{FLAG_FIVE}");
    int32_t v_804975b = bonus(); // 0x804975b
    if (v_804975b != 0) {
        // 0x8049764
        puts("GCTF{FLAG_BONUS}");
        // branch -> 0x8049790
        // 0x8049790
        v2 = 1;
        v_8049794 = *(int32_t *)20;
        if (v_8049794 != v_80496bd) {
            // 0x804979c
            __stack_chk_fail();
            v3 = v2;
            v_80497a8_2 = v3;
            // branch -> 0x80497a1
        } else {
            v_80497a8_2 = 1;
        }
        // 0x80497a1
        return v_80497a8_2;
    }
    // 0x804977b
    puts("y0u 4r3n'7 600d 3n0u6h!");
    // branch -> 0x8049790
    // 0x8049790
    v2 = 1;
    v_8049794 = *(int32_t *)20;
    if (v_8049794 != v_80496bd) {
        // 0x804979c
        __stack_chk_fail();
        v3 = v2;
        v_80497a8_2 = v3;
        // branch -> 0x80497a1
    } else {
        v_80497a8_2 = 1;
    }
    // 0x80497a1
    return v_80497a8_2;
}

// Address range: 0x80497b0 - 0x804980c
int32_t __libc_csu_init(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = 0; // edi
    int32_t v_80497b4 = __x86_get_pc_thunk_bx(); // 0x80497b4
    g1 = a1;
    _init();
    int32_t v_80497d1 = g2; // 0x80497d1
    int32_t v_80497d1_ = v_80497d1 - 268; // 0x80497d1
    int32_t v_80497d7 = v_80497b4 + 0x1743 - v_80497d1_; // 0x80497d7
    g3 = v_80497d7 / 4;
    if (v_80497d7 < 4) {
        // 0x8049805
        return v_80497d1_;
    }
    // 0x80497e0
    v1 = 0;
    int32_t v_80497f4 = 0; // 0x80497f4
    int32_t v_80497f4_ = v_80497d1; // 0x80497f4
    int32_t v_80497f4__ = *(int32_t *)(v_80497f4_ - 268 + 4 * v_80497f4); // 0x80497f4
    ((int32_t (*)(int32_t, int32_t))v_80497f4__)(a2, a3);
    int32_t v_80497fb = v1; // 0x80497fb
    int32_t v_80497fb2 = v_80497fb + 1; // 0x80497fb
    v1 = v_80497fb2;
    // branch -> 0x80497e8
    while (v_80497fb2 != g3) {
        int32_t v_8049801 = g3; // 0x8049801
        int32_t v2 = g2;
        v_80497f4 = v_80497fb2;
        v_80497f4_ = v2;
        v_80497f4__ = *(int32_t *)(v_80497f4_ - 268 + 4 * v_80497f4);
        ((int32_t (*)(int32_t, int32_t))v_80497f4__)(a2, a3);
        v_80497fb = v1;
        v_80497fb2 = v_80497fb + 1;
        v1 = v_80497fb2;
        // branch -> 0x80497e8
    }
    // 0x8049805
    return v_80497d1_;
}

// Address range: 0x804980d - 0x804980f
int32_t function_804980d(int32_t a1) {
    int32_t v_804980d = g3; // 0x804980d
    return v_804980d;
}

// Address range: 0x8049810 - 0x8049811
void __libc_csu_fini(void) {
    // 0x8049810
    return;
}

// Address range: 0x8049814 - 0x8049827
void _fini(void) {
    // 0x8049814
    __x86_get_pc_thunk_bx();
}

// --------------- Dynamically Linked Functions ---------------

// void __gmon_start(void);
// int __libc_start_main(int *(main)(int, char **, char **), int argc, char ** ubp_av, void(* init)(void), void(* fini)(void), void(* rtld_fini)(void), void(* stack_end));
// void __stack_chk_fail(void);
// int connect(int fd, __CONST_SOCKADDR_ARG addr, socklen_t len);
// char * fgets(char * restrict s, int n, FILE * restrict stream);
// int getchar(void);
// struct hostent * gethostbyname(const char * name);
// uint16_t htons(uint16_t hostshort);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// int printf(const char * restrict format, ...);
// int pthread_create(pthread_t * restrict newthread, const pthread_attr_t * restrict attr, void *(* start_routine)(void *), void * restrict arg);
// long int ptrace(enum __ptracerequest __request, ...);
// int puts(const char * s);
// int rand(void);
// ssize_t recv(int fd, void * buf, size_t n, int flags);
// double round(double);
// int scanf(const char * restrict format, ...);
// ssize_t send(int fd, const void * buf, size_t n, int flags);
// void setbuf(FILE * restrict stream, char * restrict buf);
// int socket(int domain, int type, int protocol);
// int sprintf(char * restrict s, const char * restrict format, ...);
// void srand(unsigned int seed);
// int strcmp(const char * s1, const char * s2);
// size_t strcspn(const char * s, const char * reject);
// size_t strlen(const char * s);
// char * strstr(char * haystack, const char * needle);
// time_t time(time_t * timer);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (5.4.0)
// Detected functions: 27
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-10-09 15:19:46
